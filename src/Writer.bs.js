// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Types$Ts2reason00 = require("./Types.bs.js");
var Utils$Ts2reason00 = require("./Utils.bs.js");

function make(nl, code, currentIdentation) {
  return /* record */[
          /* nl */nl,
          /* code */code,
          /* currentIdentation */currentIdentation
        ];
}

function write(state, text) {
  return /* record */[
          /* nl */state[/* nl */0],
          /* code */state[/* code */1] + text,
          /* currentIdentation */state[/* currentIdentation */2]
        ];
}

function increaseIndent(state) {
  return /* record */[
          /* nl */state[/* nl */0],
          /* code */state[/* code */1],
          /* currentIdentation */state[/* currentIdentation */2] + 1 | 0
        ];
}

function decreaseIndent(state) {
  return /* record */[
          /* nl */state[/* nl */0],
          /* code */state[/* code */1],
          /* currentIdentation */state[/* currentIdentation */2] - 1 | 0
        ];
}

function getCode(state) {
  return state[/* code */1];
}

function writeComment(state, text) {
  return write(state, "/* " + (String(text) + " */"));
}

function writeNewLine(state) {
  var state$1 = write(state, state[/* nl */0]);
  return write(state$1, Utils$Ts2reason00.makeIndent((state$1[/* currentIdentation */2] << 1)));
}

function writeRawJs(state, text) {
  return write(state, "[%bs.raw {| " + (String(text) + " |}]"));
}

function writeReasonType(state, typ) {
  var match = typ[/* ns */0];
  var namespaceSplit = match.length !== 0 ? "_" : "";
  return write(write(write(write(state, "t_"), Utils$Ts2reason00.createNameSpaceName(typ[/* ns */0])), namespaceSplit), typ[/* id */1]);
}

function writeType(state, tsType, types) {
  var match = Types$Ts2reason00.TsType[/* getText */0](tsType);
  switch (match) {
    case "boolean" : 
        return write(state, "bool");
    case "number" : 
        return write(state, "float");
    case "string" : 
        return write(state, "string");
    default:
      var match$1 = List.filter((function (tp) {
                return tp[/* id */1] === Types$Ts2reason00.TsType[/* getText */0](tsType);
              }))($$Array.to_list(types));
      if (match$1) {
        return writeReasonType(state, match$1[0]);
      } else {
        return write(state, "t_TODO");
      }
  }
}

function writeIf(state, condition, thenText, elseText) {
  if (condition) {
    return write(state, thenText);
  } else {
    return write(state, elseText);
  }
}

function writeParameterName(state, name, startWithUnderline) {
  return writeIf(state, startWithUnderline, "_" + name, Utils$Ts2reason00.fixIfItsAReservedWork(name));
}

function writeParameter(state, par, types) {
  return writeType(write(writeParameterName(state, Types$Ts2reason00.TsParDecl[/* getName */1](par), true), ": "), Types$Ts2reason00.TsParDecl[/* getType */0](par), types);
}

function writeArgumentsToMethodDecl(state, pars, types) {
  var state$1 = write(state, "(_inst: t");
  return write($$Array.fold_left((function (state, par) {
                    return writeParameter(write(state, ", "), par, types);
                  }), state$1, pars), ")");
}

function writeArgumentsToFunctionDecl(state, pars, types) {
  var state$1 = write(state, "(");
  var param = $$Array.fold_left((function (param, par) {
          var i = param[1];
          return /* tuple */[
                  writeParameter(writeIf(param[0], i === 0, "", ", "), par, types),
                  i + 1 | 0
                ];
        }), /* tuple */[
        state$1,
        0
      ], pars);
  return write(param[0], ")");
}

function writeModuleNameFrom(state, typ) {
  return write(state, Utils$Ts2reason00.capitalize(Utils$Ts2reason00.normalizeName(typ[/* id */1])));
}

function writeModuleName(state, ns) {
  return write(state, Utils$Ts2reason00.capitalize(Utils$Ts2reason00.normalizeName(Caml_array.caml_array_get(ns, ns.length - 1 | 0))));
}

function writeGetPropertyDecl(state, typ, types, names) {
  var match = typ[/* node */3];
  if (match !== undefined) {
    var match$1 = Utils$Ts2reason00.toUniqueName("get" + Utils$Ts2reason00.capitalize(typ[/* id */1]), names);
    var state$1 = write(write(write(writeType(write(write(write(state, "let "), match$1[0]), " = (_inst: t): "), Types$Ts2reason00.TypeKind[/* getType */0](Caml_option.valFromOption(match)), types), " => [%bs.raw {| _inst."), typ[/* id */1]), " |}];");
    return /* tuple */[
            state$1,
            match$1[1]
          ];
  } else {
    return /* tuple */[
            write(state, "!ERROR!"),
            names
          ];
  }
}

exports.make = make;
exports.write = write;
exports.increaseIndent = increaseIndent;
exports.decreaseIndent = decreaseIndent;
exports.getCode = getCode;
exports.writeComment = writeComment;
exports.writeNewLine = writeNewLine;
exports.writeRawJs = writeRawJs;
exports.writeReasonType = writeReasonType;
exports.writeType = writeType;
exports.writeIf = writeIf;
exports.writeParameterName = writeParameterName;
exports.writeParameter = writeParameter;
exports.writeArgumentsToMethodDecl = writeArgumentsToMethodDecl;
exports.writeArgumentsToFunctionDecl = writeArgumentsToFunctionDecl;
exports.writeModuleNameFrom = writeModuleNameFrom;
exports.writeModuleName = writeModuleName;
exports.writeGetPropertyDecl = writeGetPropertyDecl;
/* No side effect */
